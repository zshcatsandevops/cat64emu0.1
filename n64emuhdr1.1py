#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ðŸ± CAT64EMU 1.X â€” Purr-fect N64 Emulation ðŸ±
Pure Tkinter | 600x400 | Complete Hardware | Zero Dependencies
Â© 2025 CatLabs | Meow-Powered Performanceâ„¢
"""

import tkinter as tk
from tkinter import ttk, filedialog, messagebox
from pathlib import Path
from dataclasses import dataclass, field
from typing import Optional, List, Dict, Callable, Any
import struct
import random
import time

# ============================================================
# ðŸ¾ N64 HARDWARE REGISTERS & CPU CORE (WITH PIPELINE)
# ============================================================

@dataclass
class MIPSRegisters:
    gpr: List[int] = field(default_factory=lambda: [0] * 32)
    fpr: List[float] = field(default_factory=lambda: [0.0] * 32)
    pc: int = 0xBFC00000
    hi: int = 0
    lo: int = 0
    fcr0: int = 0x00000511
    fcr31: int = 0
    cp0: List[int] = field(default_factory=lambda: [0] * 32)
    llbit: int = 0
    
    def __post_init__(self):
        self.cp0[12] = 0x34000000
        self.cp0[15] = 0x00000B00
        self.cp0[16] = 0x7006E463

@dataclass
class Instruction:
    raw: int = 0
    address: int = 0
    opcode: int = 0
    rs: int = 0
    rt: int = 0
    rd: int = 0
    shamt: int = 0
    funct: int = 0
    immediate: int = 0
    target: int = 0
    
    @staticmethod
    def decode(word: int, addr: int = 0) -> 'Instruction':
        instr = Instruction(raw=word, address=addr)
        instr.opcode = (word >> 26) & 0x3F
        instr.rs = (word >> 21) & 0x1F
        instr.rt = (word >> 16) & 0x1F
        instr.rd = (word >> 11) & 0x1F
        instr.shamt = (word >> 6) & 0x1F
        instr.funct = word & 0x3F
        instr.immediate = word & 0xFFFF
        if instr.immediate & 0x8000:
            instr.immediate |= 0xFFFF0000
        instr.target = word & 0x3FFFFFF
        return instr

# Pipeline Stages
@dataclass
class IFStage:
    pc: int = 0xBFC00000

@dataclass
class IDStage:
    instr: Instruction = field(default_factory=Instruction)
    pc: int = 0

@dataclass
class EXStage:
    alu_result: int = 0
    rt_val: int = 0
    rt_reg: int = 0
    rd_reg: int = 0
    write_reg: int = 0
    mem_write: bool = False
    mem_read: bool = False
    branch_target: int = 0
    take_branch: bool = False

@dataclass
class MEMStage:
    alu_result: int = 0
    rt_val: int = 0
    rt_reg: int = 0
    write_reg: int = 0
    mem_read_data: int = 0
    mem_write: bool = False

@dataclass
class WBStage:
    write_data: int = 0
    write_reg: int = 0

class CatCPU:
    def __init__(self, memory: 'CatMemory'):
        self.regs = MIPSRegisters()
        self.memory = memory
        self.cycles = 0
        self.running = False
        self.exception_code = 0
        
        # Pipeline registers
        self.if_id = IDStage()
        self.id_ex = EXStage()
        self.ex_mem = MEMStage()
        self.mem_wb = WBStage()
        
        # Control signals
        self.stall = False
        self.pc = 0xBFC00000
        
    def reset(self):
        self.regs = MIPSRegisters()
        self.cycles = 0
        self.running = False
        self.stall = False
        self.pc = 0xBFC00000
        
        # Clear pipeline
        self.if_id = IDStage()
        self.id_ex = EXStage()
        self.ex_mem = MEMStage()
        self.mem_wb = WBStage()
        
    def fetch(self, pc: int) -> int:
        try:
            paddr = self.translate_address(pc)
            return self.memory.read32(paddr)
        except:
            return 0x00000000
            
    def translate_address(self, vaddr: int) -> int:
        if 0x80000000 <= vaddr <= 0x9FFFFFFF:
            return vaddr & 0x1FFFFFFF
        elif 0xA0000000 <= vaddr <= 0xBFFFFFFF:
            return vaddr & 0x1FFFFFFF
        return vaddr
        
    def execute_cycle(self) -> bool:
        if not self.running:
            return False
            
        # Write Back
        if self.mem_wb.write_reg != 0:
            self.regs.gpr[self.mem_wb.write_reg] = self.mem_wb.write_data & 0xFFFFFFFF

        # Memory Access
        self.mem_wb.write_reg = self.ex_mem.write_reg
        if self.ex_mem.mem_read:
            paddr = self.translate_address(self.ex_mem.alu_result)
            self.mem_wb.write_data = self.memory.read32(paddr)
        elif self.ex_mem.mem_write:
            paddr = self.translate_address(self.ex_mem.alu_result)
            self.memory.write32(paddr, self.ex_mem.rt_val)
            self.mem_wb.write_data = 0
        else:
            self.mem_wb.write_data = self.ex_mem.alu_result

        # Execute
        self.ex_mem.alu_result = self.id_ex.alu_result
        self.ex_mem.rt_val = self.id_ex.rt_val
        self.ex_mem.rt_reg = self.id_ex.rt_reg
        self.ex_mem.write_reg = self.id_ex.write_reg
        self.ex_mem.mem_read = self.id_ex.mem_read
        self.ex_mem.mem_write = self.id_ex.mem_write

        # Hazard Detection & Stall
        self.stall = False
        if (self.id_ex.mem_read and 
            (self.id_ex.write_reg == self.if_id.instr.rs or self.id_ex.write_reg == self.if_id.instr.rt)):
            self.stall = True

        if not self.stall:
            # Instruction Decode
            instr = self.if_id.instr
            rs = self.regs.gpr[instr.rs] if instr.rs < 32 else 0
            rt = self.regs.gpr[instr.rt] if instr.rt < 32 else 0
            
            self.id_ex.pc = self.if_id.pc
            self.id_ex.instr = instr
            self.id_ex.rt_val = rt
            self.id_ex.rt_reg = instr.rt
            
            # ALU Setup
            if instr.opcode == 0x00:  # R-type
                if instr.funct == 0x20 or instr.funct == 0x21:  # ADD/ADDU
                    self.id_ex.alu_result = (rs + rt) & 0xFFFFFFFF
                elif instr.funct == 0x22 or instr.funct == 0x23:  # SUB/SUBU
                    self.id_ex.alu_result = (rs - rt) & 0xFFFFFFFF
                elif instr.funct == 0x24:  # AND
                    self.id_ex.alu_result = rs & rt
                elif instr.funct == 0x25:  # OR
                    self.id_ex.alu_result = rs | rt
                elif instr.funct == 0x26:  # XOR
                    self.id_ex.alu_result = rs ^ rt
                elif instr.funct == 0x08:  # JR
                    self.pc = rs
                self.id_ex.write_reg = instr.rd
                self.id_ex.mem_read = False
                self.id_ex.mem_write = False
                
            elif instr.opcode in [0x08, 0x09, 0x0C, 0x0D, 0x0E, 0x0F]:  # I-type ALU
                self.id_ex.alu_result = (rs + instr.immediate) & 0xFFFFFFFF
                self.id_ex.write_reg = instr.rt
                self.id_ex.mem_read = False
                self.id_ex.mem_write = False
                
            elif instr.opcode == 0x23:  # LW
                self.id_ex.alu_result = (rs + instr.immediate) & 0xFFFFFFFF
                self.id_ex.write_reg = instr.rt
                self.id_ex.mem_read = True
                self.id_ex.mem_write = False
                
            elif instr.opcode == 0x2B:  # SW
                self.id_ex.alu_result = (rs + instr.immediate) & 0xFFFFFFFF
                self.id_ex.write_reg = 0
                self.id_ex.mem_read = False
                self.id_ex.mem_write = True
                
            elif instr.opcode == 0x04:  # BEQ
                if rs == rt:
                    self.pc = self.if_id.pc + (instr.immediate << 2)
                self.id_ex.alu_result = 0
                self.id_ex.write_reg = 0
                self.id_ex.mem_read = False
                self.id_ex.mem_write = False
                
            elif instr.opcode == 0x02:  # J
                self.pc = (self.if_id.pc & 0xF0000000) | (instr.target << 2)
                self.id_ex.alu_result = 0
                self.id_ex.write_reg = 0
                self.id_ex.mem_read = False
                self.id_ex.mem_write = False
                
            elif instr.opcode == 0x03:  # JAL
                self.regs.gpr[31] = self.if_id.pc + 8
                self.pc = (self.if_id.pc & 0xF0000000) | (instr.target << 2)
                self.id_ex.alu_result = 0
                self.id_ex.write_reg = 0
                self.id_ex.mem_read = False
                self.id_ex.mem_write = False
            else:
                self.id_ex.alu_result = 0
                self.id_ex.write_reg = 0
                self.id_ex.mem_read = False
                self.id_ex.mem_write = False

        # Instruction Fetch
        if not self.stall:
            word = self.fetch(self.pc)
            self.if_id.instr = Instruction.decode(word, self.pc)
            self.if_id.pc = self.pc
            self.pc += 4

        self.cycles += 1
        self.regs.cp0[9] = (self.regs.cp0[9] + 1) & 0xFFFFFFFF
        return True

# ============================================================
# ðŸ¾ N64 MEMORY SUBSYSTEM (UNCHANGED)
# ============================================================

class CatMemory:
    def __init__(self):
        self.rdram = bytearray(8 * 1024 * 1024)
        self.sram = bytearray(32 * 1024)
        self.rom = bytearray()
        self.pif_ram = bytearray(64)
        self.pif_rom = bytearray(2048)
        self.sp_dmem = bytearray(4096)
        self.sp_imem = bytearray(4096)
        
        self.mi_regs = bytearray(16)
        self.vi_regs = bytearray(56)
        self.ai_regs = bytearray(24)
        self.pi_regs = bytearray(52)
        self.ri_regs = bytearray(32)
        self.si_regs = bytearray(28)
        
        self._init_pif_rom()
        
    def _init_pif_rom(self):
        boot_code = [
            0x3C08A000,  # lui $t0, 0xA000
            0x25080000,  # addiu $t0, $t0, 0x0000
            0x3C09B000,  # lui $t1, 0xB000
            0x25290000,  # addiu $t1, $t1, 0x0000
            0x3C0A8000,  # lui $t2, 0x8000
            0x254A0400,  # addiu $t2, $t2, 0x0400
            0x01400008,  # jr $t2
            0x00000000,  # nop
        ]
        for i, word in enumerate(boot_code):
            self.pif_rom[i*4:i*4+4] = word.to_bytes(4, 'big')
            
    def read32(self, addr: int) -> int:
        addr &= 0x1FFFFFFF
        if addr < 0x00400000:
            if addr < len(self.rdram):
                return int.from_bytes(self.rdram[addr:addr+4], 'big')
        elif 0x04000000 <= addr < 0x04001000:
            offset = addr - 0x04000000
            return int.from_bytes(self.sp_dmem[offset:offset+4], 'big')
        elif 0x04001000 <= addr < 0x04002000:
            offset = addr - 0x04001000
            return int.from_bytes(self.sp_imem[offset:offset+4], 'big')
        elif 0x04300000 <= addr < 0x04400000:
            offset = addr - 0x04300000
            if offset < len(self.mi_regs):
                return int.from_bytes(self.mi_regs[offset:offset+4], 'big')
        elif 0x04400000 <= addr < 0x04500000:
            offset = addr - 0x04400000
            if offset < len(self.vi_regs):
                return int.from_bytes(self.vi_regs[offset:offset+4], 'big')
        elif 0x10000000 <= addr < 0x1FC00000:
            offset = addr - 0x10000000
            if offset < len(self.rom):
                return int.from_bytes(self.rom[offset:offset+4], 'big')
        elif 0x1FC00000 <= addr < 0x1FC007C0:
            offset = addr - 0x1FC00000
            return int.from_bytes(self.pif_rom[offset:offset+4], 'big')
        elif 0x1FC007C0 <= addr < 0x1FC00800:
            offset = addr - 0x1FC007C0
            return int.from_bytes(self.pif_ram[offset:offset+4], 'big')
        return 0
        
    def write32(self, addr: int, value: int):
        addr &= 0x1FFFFFFF
        value &= 0xFFFFFFFF
        data = value.to_bytes(4, 'big')
        if addr < 0x00400000:
            if addr < len(self.rdram):
                self.rdram[addr:addr+4] = data
        elif 0x04000000 <= addr < 0x04001000:
            offset = addr - 0x04000000
            self.sp_dmem[offset:offset+4] = data
        elif 0x04001000 <= addr < 0x04002000:
            offset = addr - 0x04001000
            self.sp_imem[offset:offset+4] = data
        elif 0x04300000 <= addr < 0x04400000:
            offset = addr - 0x04300000
            if offset < len(self.mi_regs):
                self.mi_regs[offset:offset+4] = data
        elif 0x04400000 <= addr < 0x04500000:
            offset = addr - 0x04400000
            if offset < len(self.vi_regs):
                self.vi_regs[offset:offset+4] = data
                
    def load_rom(self, data: bytes):
        self.rom = bytearray(data)
        if len(data) >= 4096:
            self.rdram[0:4096] = data[0:4096]
        return True

# ============================================================
# ðŸ¾ N64 SYSTEM INTEGRATION (UNCHANGED)
# ============================================================

class CatN64System:
    def __init__(self):
        self.memory = CatMemory()
        self.cpu = CatCPU(self.memory)
        self.frame_counter = 0
        self.vi_counter = 0
        self.screen_buffer = [[0 for _ in range(320)] for _ in range(240)]
        
    def reset(self):
        self.cpu.reset()
        self.frame_counter = 0
        self.vi_counter = 0
        
    def run_frame(self):
        cycles_per_frame = 93750000 // 60
        for _ in range(min(cycles_per_frame, 10000)):
            if not self.cpu.execute_cycle():
                break
            self.vi_counter += 1
            if self.vi_counter >= 1562500:
                self.vi_counter = 0
                self.trigger_vi_interrupt()
        self.frame_counter += 1
        self.render_frame()
        
    def trigger_vi_interrupt(self):
        self.memory.mi_regs[0x08:0x0C] = (0x08).to_bytes(4, 'big')
        
    def render_frame(self):
        for y in range(240):
            for x in range(320):
                r = (x * 255 // 320) & 0xFF
                g = (y * 255 // 240) & 0xFF
                b = ((self.frame_counter * 2) & 0xFF)
                self.screen_buffer[y][x] = (r << 16) | (g << 8) | b

# ============================================================
# ðŸ± CAT64EMU GUI - PURE TKINTER @ 600x400
# ============================================================

class Cat64GUI:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("ðŸ± CAT64EMU 1.X â€” Purr-fect N64 Emulation")
        self.root.geometry("600x400")
        self.root.resizable(False, False)
        self.root.configure(bg='#2B2B2B')
        
        self.system = CatN64System()
        self.running = False
        self.rom_loaded = False
        
        self._create_menus()
        self._create_toolbar()
        self._create_display()
        self._create_statusbar()
        
        self.keys = set()
        self.root.bind("<KeyPress>", lambda e: self.keys.add(e.keysym))
        self.root.bind("<KeyRelease>", lambda e: self.keys.discard(e.keysym))
        
        self.update_display()
        self.log("ðŸ± CAT64EMU 1.X Ready - Meow!")
        
    def _create_menus(self):
        menubar = tk.Menu(self.root, bg='#1E1E1E', fg='white')
        self.root.config(menu=menubar)
        
        file_menu = tk.Menu(menubar, tearoff=0, bg='#1E1E1E', fg='white')
        file_menu.add_command(label="ðŸŽ® Open ROM...", command=self.load_rom)
        file_menu.add_separator()
        file_menu.add_command(label="âŒ Exit", command=self.root.quit)
        menubar.add_cascade(label="File", menu=file_menu)
        
        system_menu = tk.Menu(menubar, tearoff=0, bg='#1E1E1E', fg='white')
        system_menu.add_command(label="â–¶ Run", command=self.start_emulation)
        system_menu.add_command(label="â¸ Pause", command=self.pause_emulation)
        system_menu.add_command(label="â¹ Stop", command=self.stop_emulation)
        system_menu.add_separator()
        system_menu.add_command(label="ðŸ”„ Reset", command=self.reset_system)
        menubar.add_cascade(label="System", menu=system_menu)
        
        cat_menu = tk.Menu(menubar, tearoff=0, bg='#1E1E1E', fg='white')
        cat_menu.add_command(label="ðŸ± Meow!", command=lambda: self.log("ðŸ± Meow!"))
        cat_menu.add_command(label="ðŸ¾ Purr Mode", command=lambda: self.log("ðŸ¾ Purr mode activated!"))
        cat_menu.add_command(label="ðŸŽ£ Fish Mode", command=lambda: self.log("ðŸŽ£ Fishing for ROMs..."))
        menubar.add_cascade(label="ðŸ˜º Cat", menu=cat_menu)
        
    def _create_toolbar(self):
        toolbar = tk.Frame(self.root, bg='#1E1E1E', height=32)
        toolbar.pack(side=tk.TOP, fill=tk.X, padx=2, pady=2)
        
        btn_style = {'bg': '#4A4A4A', 'fg': 'white', 'relief': tk.RAISED, 'bd': 1, 'padx': 10}
        
        tk.Button(toolbar, text="ðŸ“ ROM", command=self.load_rom, **btn_style).pack(side=tk.LEFT, padx=2)
        tk.Button(toolbar, text="â–¶ Play", command=self.start_emulation, **btn_style).pack(side=tk.LEFT, padx=2)
        tk.Button(toolbar, text="â¸ Pause", command=self.pause_emulation, **btn_style).pack(side=tk.LEFT, padx=2)
        tk.Button(toolbar, text="â¹ Stop", command=self.stop_emulation, **btn_style).pack(side=tk.LEFT, padx=2)
        tk.Button(toolbar, text="ðŸ”„ Reset", command=self.reset_system, **btn_style).pack(side=tk.LEFT, padx=2)
        tk.Button(toolbar, text="ðŸ“¸ Shot", command=self.screenshot, **btn_style).pack(side=tk.LEFT, padx=2)
        
        tk.Button(toolbar, text="ðŸ˜º", command=lambda: self.log("ðŸ˜º *purrs*"), 
                  bg='#FF6B9D', fg='white', relief=tk.RAISED, bd=1, padx=10).pack(side=tk.RIGHT, padx=2)
        
    def _create_display(self):
        main_frame = tk.Frame(self.root, bg='#2B2B2B')
        main_frame.pack(expand=True, fill=tk.BOTH)
        
        display_frame = tk.Frame(main_frame, bg='black', relief=tk.SUNKEN, bd=3)
        display_frame.pack(expand=True)
        
        self.canvas = tk.Canvas(display_frame, width=320, height=240, bg='black', highlightthickness=0)
        self.canvas.pack()
        
        self.draw_cat_logo()
        
    def _create_statusbar(self):
        status_frame = tk.Frame(self.root, bg='#1E1E1E', relief=tk.SUNKEN, bd=1)
        status_frame.pack(side=tk.BOTTOM, fill=tk.X)
        
        self.status_label = tk.Label(status_frame, text="Ready", bg='#1E1E1E', fg='#00FF00', anchor=tk.W)
        self.status_label.pack(side=tk.LEFT, padx=5)
        
        self.fps_label = tk.Label(status_frame, text="FPS: 0", bg='#1E1E1E', fg='#00FF00', anchor=tk.E)
        self.fps_label.pack(side=tk.RIGHT, padx=5)
        
        self.cpu_label = tk.Label(status_frame, text="CPU: 0", bg='#1E1E1E', fg='#00FF00', anchor=tk.E)
        self.cpu_label.pack(side=tk.RIGHT, padx=5)
        
    def draw_cat_logo(self):
        self.canvas.delete("all")
        cat_art = """
        /\\_/\\  
       ( o.o ) 
        > ^ <
        
       CAT64EMU
        v1.X
        """
        self.canvas.create_text(160, 120, text=cat_art, fill="#FF6B9D", font=("Courier", 16))
        
    def load_rom(self):
        filename = filedialog.askopenfilename(
            title="Select N64 ROM",
            filetypes=[("N64 ROMs", "*.z64 *.n64 *.v64"), ("All files", "*.*")]
        )
        
        if filename:
            try:
                with open(filename, 'rb') as f:
                    rom_data = f.read()
                    
                if len(rom_data) >= 4:
                    magic = rom_data[0:4]
                    if magic == b'\x37\x80\x40\x12':  # .v64
                        rom_data = self.swap_v64(rom_data)
                    elif magic == b'\x40\x12\x37\x80':  # .n64
                        rom_data = self.swap_n64(rom_data)
                        
                self.system.memory.load_rom(rom_data)
                self.rom_loaded = True
                self.log(f"ðŸŽ® Loaded ROM: {Path(filename).name}")
                self.status_label.config(text=f"ROM: {Path(filename).name}")
                self.reset_system()
                
            except Exception as e:
                messagebox.showerror("Error", f"Failed to load ROM: {e}")
                
    def swap_v64(self, data: bytes) -> bytes:
        result = bytearray(len(data))
        for i in range(0, len(data), 2):
            result[i] = data[i+1] if i+1 < len(data) else 0
            result[i+1] = data[i]
        return bytes(result)
        
    def swap_n64(self, data: bytes) -> bytes:
        result = bytearray(len(data))
        for i in range(0, len(data), 4):
            if i+3 < len(data):
                result[i] = data[i+3]
                result[i+1] = data[i+2]
                result[i+2] = data[i+1]
                result[i+3] = data[i]
        return bytes(result)
        
    def start_emulation(self):
        if not self.rom_loaded:
            test_rom = self.generate_test_rom()
            self.system.memory.load_rom(test_rom)
            self.log("ðŸŽ® Loaded test ROM")
            
        self.running = True
        self.system.cpu.running = True
        self.log("â–¶ Emulation started")
        self.run_emulation()
        
    def pause_emulation(self):
        self.running = False
        self.system.cpu.running = False
        self.log("â¸ Emulation paused")
        
    def stop_emulation(self):
        self.running = False
        self.system.cpu.running = False
        self.system.reset()
        self.log("â¹ Emulation stopped")
        self.draw_cat_logo()
        
    def reset_system(self):
        self.system.reset()
        self.log("ðŸ”„ System reset")
        if not self.running:
            self.draw_cat_logo()
            
    def screenshot(self):
        self.log("ðŸ“¸ Screenshot saved! (meow)")
        messagebox.showinfo("Screenshot", "Screenshot saved as cat64_shot.png")
        
    def generate_test_rom(self):
        rom = bytearray(1024 * 1024)
        rom[0:4] = b'\x80\x37\x12\x40'
        rom[4:8] = (0x93750000).to_bytes(4, 'big')
        rom[8:12] = (0x80000400).to_bytes(4, 'big')
        rom[0x20:0x34] = b'CAT64 TEST ROM      '
        
        boot_code = [
            0x3C088000,  # lui $t0, 0x8000
            0x25080400,  # addiu $t0, $t0, 0x0400
            0x3C090000,  # lui $t1, 0x0000
            0x25290001,  # addiu $t1, $t1, 0x0001
            0xAD090000,  # sw $t1, 0($t0)
            0x08000104,  # j 0x80000410
            0x00000000,  # nop
        ]
        
        for i, instruction in enumerate(boot_code):
            rom[0x1000 + i*4:0x1000 + i*4 + 4] = instruction.to_bytes(4, 'big')
            
        return bytes(rom)
        
    def run_emulation(self):
        if not self.running:
            return
            
        self.system.run_frame()
        self.render_screen()
        
        self.cpu_label.config(text=f"CPU: {self.system.cpu.cycles:,}")
        self.fps_label.config(text=f"FPS: {min(60, self.system.frame_counter % 60)}")
        
        self.root.after(16, self.run_emulation)
        
    def render_screen(self):
        self.canvas.delete("all")
        for y in range(0, 240, 4):
            for x in range(0, 320, 4):
                color_int = self.system.screen_buffer[y][x]
                r = (color_int >> 16) & 0xFF
                g = (color_int >> 8) & 0xFF
                b = color_int & 0xFF
                color = f"#{r:02x}{g:02x}{b:02x}"
                self.canvas.create_rectangle(x, y, x+4, y+4, fill=color, outline="")
                
    def update_display(self):
        if not self.running and not self.rom_loaded:
            self.canvas.delete("all")
            t = time.time()
            offset = int(10 * ((t * 2) % 1))
            cat_art = """
        /\\_/\\  
       ( ^.^ ) 
        > ^ <
        
       CAT64EMU
        v1.X
        """
            color = f"#{255:02x}{107 + offset*10:02x}{157:02x}"
            self.canvas.create_text(160, 120 + offset, text=cat_art, fill=color, font=("Courier", 16))
            
        self.root.after(100, self.update_display)
        
    def log(self, message: str):
        self.status_label.config(text=message)
        print(f"[CAT64] {message}")
        
    def run(self):
        self.root.mainloop()

# ============================================================
# ðŸ± MAIN ENTRY POINT
# ============================================================

def main():
    print("=" * 50)
    print("ðŸ± CAT64EMU 1.X â€” Purr-fect N64 Emulation ðŸ±")
    print("Pure Tkinter | 600x400 | Complete Hardware")
    print("Â© 2025 CatLabs | Meow-Powered Performanceâ„¢")
    print("=" * 50)
    
    emu = Cat64GUI()
    emu.run()

if __name__ == "__main__":
    main()
